import nest
import matplotlib.pyplot as plt
import io
import os
import re
from contextlib import contextmanager
from collections import defaultdict
import numpy as np
import random

stdp_amplitude = 36.0
# Time constant of STDP curve in milliseconds
stdp_tau = 64.0

# -------------------------
# NEST setup
# -------------------------
neuron_params = {
    "C_m": 10.0,
    "tau_m": 10.0,
    "V_reset": 0.0,
    "V_th": 20.0,
    "t_ref": 0.5,
    "tau_syn_ex": 0.1,
    "tau_minus": 0.5,
    "V_m": 0.0,
    "E_L": 0.0,
}

SEED = 12350

# reset kernel first (very important)
nest.ResetKernel()

# force single-threaded deterministic execution (recommended for debugging)
# if you want multi-threaded reproducibility you must ensure the same number
# of threads on each run and accept more complexity.
nest.SetKernelStatus({
    "rng_seed": SEED,
})



# also seed Python / NumPy RNGs (so any np.random or random calls are reproducible)
np.random.seed(SEED)
random.seed(SEED)
nest.Install("mymodule")

# Create neurons
neuron = nest.Create("parrot_neuron")
post_neurons = nest.Create("iaf_psc_alpha", 3, params=neuron_params)

# Recorders
sd_pre = nest.Create("spike_recorder")
sd_post = nest.Create("spike_recorder", len(post_neurons))

nest.Connect(neuron, sd_pre)
for i, n in enumerate(post_neurons):
    nest.Connect(n, sd_post[i])

# Input setup
spike_times = np.arange(0.5, 201.0, 1.0).tolist()
pre = nest.Create("spike_generator", {"spike_times": spike_times})

# Dopamine setup
vt = nest.Create("volume_transmitter")
dopa_spike_times = [float(t) for t in range(1, 1000, 20)]
mod_spikes = nest.Create("spike_generator", {"spike_times": dopa_spike_times})
dopa = nest.Create("parrot_neuron")
nest.Connect(mod_spikes, dopa)
nest.Connect(dopa, vt)

# Synapse model
# nest.SetDefaults(
#     "delayed_synapse",
#     {
#         "volume_transmitter": vt,
#         "tau_c": 50,
#         "tau_c_delay": 200,
#         "tau_n": 10,
#         "tau_plus": 50,
#         "Wmin": 150,
#         "Wmax": 500,
#         "b": 0.0,
#         "A_plus": 0.75,
#     },
# )

nest.SetDefaults(
    "delayed_synapse",
    {
        "volume_transmitter": vt,
        "Wmin": 100,
        "Wmax": 1000,
        "tau_c": 1000,
        "tau_c_delay": 200,
        "tau_n": 10,
        "tau_plus": 0.5,
        "b": 0.0,
        "A_plus": 0.1,
        "A_minus": 0
        },
    )

# Motor noise
n_motor = len(post_neurons)

poisson_motor_ex = nest.Create("poisson_generator", n_motor, params={"rate": 0})
poisson_motor_inh = nest.Create("poisson_generator", n_motor, params={"rate": 0})

nest.Connect(
    poisson_motor_ex,
    post_neurons,
    conn_spec={"rule": "one_to_one"},
    syn_spec={"weight": 500}
)
nest.Connect(
    poisson_motor_inh,
    post_neurons,
    conn_spec={"rule": "one_to_one"},
    syn_spec={"weight": 500}
)
poisson_pre_ex = nest.Create("poisson_generator", 1, params={"rate": 0})
poisson_pre_inh = nest.Create("poisson_generator", 1, params={"rate": 0})

nest.Connect(
    poisson_pre_ex,
    neuron,
    conn_spec={"rule": "one_to_one"},
    syn_spec={"weight": 500}
)
nest.Connect(
    poisson_pre_inh,
    neuron,
    conn_spec={"rule": "one_to_one"},
    syn_spec={"weight": 500}
)

# Connect pre → parrot → posts
nest.Connect(pre, neuron)
for i, post in enumerate(post_neurons):
    nest.Connect(
        neuron,
        post,
        {"rule": "all_to_all"},
        {"synapse_model": "delayed_synapse", "weight": 150 + 8 * i, "delay": 1.0},
    )

print("Connections:")
print(nest.GetConnections(neuron, post_neurons))

# -------------------------
# Capture C++ stdout
# -------------------------
@contextmanager
def capture_cpp_stdout():
    old_stdout_fd = os.dup(1)
    r_fd, w_fd = os.pipe()
    os.dup2(w_fd, 1)
    os.close(w_fd)
    try:
        yield r_fd
    finally:
        os.dup2(old_stdout_fd, 1)
        os.close(old_stdout_fd)

# -------------------------
# Pattern for delayed_synapse debug
# -------------------------
pattern = re.compile(
    r"post_node_id=(\d+).*?t_trig=(\d+).*?c_current=([\-0-9.eE]+)"
)

# -------------------------
# Run simulation and capture logs
# -------------------------
neuron_data = defaultdict(list)
weight_data = defaultdict(list)
time_points = set()
full_output = []
sim_duration = 1000

for step in range(sim_duration):
    with capture_cpp_stdout() as r_fd:
        nest.Simulate(1.0)
        os.close(1)
        output = os.read(r_fd, 50_000).decode(errors="ignore")
        full_output.append(output)

    # Parse c_current values
    for m in pattern.finditer(output):
        post_id = int(m.group(1))
        t_trig = int(m.group(2))
        c_val = float(m.group(3))
        neuron_data[post_id].append((t_trig, c_val))
        time_points.add(t_trig)

    # Track weights
    conns = nest.GetConnections(neuron, post_neurons)
    for c in conns:
        w = c.weight
        tgt = c.target
        weight_data[tgt].append(w)

print("\n===== CAPTURED NEST DEBUG OUTPUT =====\n")
print("".join(full_output))

# ---------------------------------------
# Get spike data
# ---------------------------------------
spikes_pre = nest.GetStatus(sd_pre, "events")[0]
times_pre = spikes_pre["times"]

spikes_post = [nest.GetStatus(sd_post[i], "events")[0] for i in range(len(post_neurons))]
times_post = [sp["times"] for sp in spikes_post]

# ---------------------------------------
# Plot stacked figure with firing rates included
# ---------------------------------------
n_subplots = 2 + len(post_neurons) + 2  # +1 for weights, +1 for firing rates
fig, axes = plt.subplots(n_subplots, 1, figsize=(10, 3 * n_subplots), sharex=True)

# --- Pre raster ---
axes[0].eventplot([times_pre], colors=["blue"], lineoffsets=[1], linelengths=0.8)
axes[0].set_yticks([1])
axes[0].set_yticklabels(["Pre"])
axes[0].set_title("Presynaptic Spikes")
axes[0].grid(True, axis="x", linestyle="--", alpha=0.6)

# --- Post rasters ---
axes[1].eventplot(
    [times_post[i] for i in range(len(post_neurons))],
    colors=["red"] * len(post_neurons),
    lineoffsets=np.arange(1, len(post_neurons) + 1),
    linelengths=0.8,
)
axes[1].set_yticks(np.arange(1, len(post_neurons) + 1))
axes[1].set_yticklabels([f"Post {i}" for i in range(len(post_neurons))])
axes[1].set_title("Postsynaptic Spikes")
axes[1].grid(True, axis="x", linestyle="--", alpha=0.6)

# --- c_current per neuron ---
for i, (post_id, entries) in enumerate(sorted(neuron_data.items(), reverse=True)):
    ax = axes[2 + i]
    if not entries:
        continue
    x_vals = [e[0] for e in entries]
    y_vals = [e[1] for e in entries]
    ax.plot(x_vals, y_vals, label=f"Neuron {post_id}", color="purple")
    ax.set_ylabel("c_current")
    ax.set_title(f"Neuron {post_id} c_current")
    ax.legend()
    ax.grid(True)

# --- Weight evolution ---
ax_w = axes[-2]
for tgt, weights in sorted(weight_data.items()):
    weights = np.array(weights)
    norm_w = weights - weights[0]
    times = np.arange(len(weights)) - 200
    times = np.clip(times, 0, None)
    ax_w.plot(times, norm_w, label=f"target={tgt}")
ax_w.set_ylabel("ΔWeight (normalized)")
ax_w.set_title("Weight evolution per post neuron (shifted 200 ms earlier)")
ax_w.legend()
ax_w.grid(True)

# --- Firing rate per 50 ms bin ---
ax_fr = axes[-1]
bin_size = 50.0
n_bins = int(np.ceil(sim_duration / bin_size))
bin_edges = np.arange(0, (n_bins + 1) * bin_size, bin_size)

for i, sp in enumerate(spikes_post):
    times = np.array(sp["times"])
    n_spikes = len(times)
    duration_sec = sim_duration / 1000.0
    total_freq = n_spikes / duration_sec

    # Per-bin frequencies
    hist, _ = np.histogram(times, bins=bin_edges)
    bin_freqs = hist / (bin_size / 1000.0)
    ax_fr.plot(bin_edges[:-1] + bin_size / 2, bin_freqs, label=f"Post {i}")

    print(f"\nPost neuron {i}: {n_spikes} spikes total, avg = {total_freq:.2f} Hz")
    print(f"  Firing rates per 50 ms bin (Hz): {np.round(bin_freqs, 2)}")

ax_fr.set_xlabel("Time (ms)")
ax_fr.set_ylabel("Firing rate (Hz / 50 ms)")
ax_fr.set_title("Postsynaptic firing rates per 50 ms bin")
ax_fr.legend()
ax_fr.grid(True)

plt.tight_layout()
plt.show()
